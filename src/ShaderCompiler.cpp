#include "pch.h";
#include "ShaderCompiler.h"

using namespace CM_HlslShaderToy;

ShaderCompiler::ShaderCompiler()
{
    // Create compiler and utils.
    DxcCreateInstance(CLSID_DxcUtils, IID_PPV_ARGS(&pUtils));
    DxcCreateInstance(CLSID_DxcCompiler, IID_PPV_ARGS(&pCompiler));

    // Create default include handler. (You can create your own...)
    pUtils->CreateDefaultIncludeHandler(&pIncludeHandler);
}

bool ShaderCompiler::CompilePixelShaderFromFile(LPCWSTR filepath, IDxcBlob** ppShaderOut)
{
    //
    // COMMAND LINE:
    // dxc myshader.hlsl -E main -T ps_6_0 -Zi -D MYDEFINE=1 -Fo myshader.bin -Fd myshader.pdb -Qstrip_reflect
    //
	LPCWSTR pszArgs[] =
	{
		filepath,            // Optional shader source file name for error reporting
		                             // and for PIX shader source view.  
        L"-E", L"PSMain",            // Entry point.
        L"-T", L"ps_6_0",            // Target.
        //L"-Zs",                      // Enable debug information (slim format)
        //L"-D", L"MYDEFINE=1",        // A single define.
        //L"-Fo", L"myshader.bin",     // Optional. Stored in the pdb. 
        L"-Fd", L"myshader.pdb",     // The file name of the pdb. This must either be supplied
                                     // or the autogenerated file name must be used.
        L"-Qstrip_reflect",          // Strip reflection into a separate blob. 
	};

    // Open source file.  
    ComPtr<IDxcBlobEncoding> pSource = nullptr;
    pUtils->LoadFile(pszArgs[0], nullptr, &pSource);
    DxcBuffer Source;
    Source.Ptr = pSource->GetBufferPointer();
    Source.Size = pSource->GetBufferSize();
    Source.Encoding = DXC_CP_ACP; // Assume BOM says UTF8 or UTF16 or this is ANSI text.
    
    return CompileShader(Source, _countof(pszArgs), pszArgs, ppShaderOut);
}

bool ShaderCompiler::CompilePixelShaderFromText(size_t numChars, LPCWSTR pText, LPCWSTR filename, IDxcBlob** ppShaderOut)
{
    //
    // COMMAND LINE:
    // dxc myshader.hlsl -E main -T ps_6_0 -Zi -D MYDEFINE=1 -Fo myshader.bin -Fd myshader.pdb -Qstrip_reflect
    //
	LPCWSTR pszArgs[] =
	{
        filename,            // Optional shader source file name for error reporting
		                             // and for PIX shader source view.  
        L"-E", L"PSMain",            // Entry point.
        L"-T", L"ps_6_0",            // Target.
        //L"-Zs",                      // Enable debug information (slim format)
        //L"-D", L"MYDEFINE=1",        // A single define.
        //L"-Fo", L"myshader.bin",     // Optional. Stored in the pdb. 
        L"-Fd", L"myshader.pdb",     // The file name of the pdb. This must either be supplied
                                     // or the autogenerated file name must be used.
        L"-Qstrip_reflect",          // Strip reflection into a separate blob. 
	};

    DxcText Source;
    Source.Ptr = pText;
    Source.Size = numChars*sizeof(WCHAR);
    Source.Encoding = DXC_CP_UTF16; // Assume BOM says UTF8 or UTF16 or this is ANSI text.

    return CompileShader(Source, _countof(pszArgs), pszArgs, ppShaderOut);
}

bool ShaderCompiler::CompileShader(const DxcBuffer& sourceBuffer, size_t numArgs, LPCWSTR* pszArgs, IDxcBlob** ppShaderOut)
{
    // Compile it with specified arguments.
    ComPtr<IDxcResult> pResults;
    pCompiler->Compile(
        &sourceBuffer,                // Source buffer.
        pszArgs,                // Array of pointers to arguments.
        numArgs,      // Number of arguments.
        pIncludeHandler.Get(),        // User-provided interface to handle #include directives (optional).
        IID_PPV_ARGS(&pResults) // Compiler output status, buffer, and errors.
    );

    // Print errors if present.
    ComPtr<IDxcBlobUtf8> pErrors = nullptr;
    pResults->GetOutput(DXC_OUT_ERRORS, IID_PPV_ARGS(&pErrors), nullptr);
    // Note that d3dcompiler would return null if no errors or warnings are present.
    // IDxcCompiler3::Compile will always return an error buffer, but its length
    // will be zero if there are no warnings or errors.
    if (pErrors != nullptr && pErrors->GetStringLength() != 0)
    {
        MessageBox(NULL, from_utf8(pErrors->GetStringPointer()).c_str(), L"Warnings and Errors", MB_OK);
    }

    //Quit if failed
    HRESULT hrStatus;
    pResults->GetStatus(&hrStatus);
    if (FAILED(hrStatus))
    {
        return false;
    }

    // Get the shader binary.
    ComPtr<IDxcBlobUtf16> pShaderName = nullptr;
    pResults->GetOutput(DXC_OUT_OBJECT, IID_PPV_ARGS(ppShaderOut), &pShaderName);

    return true;
}
